import {
    ADD_WIDGET, HEADING_WIDGET, DELETE_WIDGET,
    UPDATE_WIDGET, SAVE_WIDGETS, LOAD_WIDGETS, MOVE_UP, MOVE_DOWN
} from '../constants/WidgetConstants';

import WidgetService from '../services/WidgetService';

const widgetService = WidgetService.instance
let url = window.location.href;
let tId = url.slice(url.search('topic') + 6);

let defaultWidget = (id, widgetIndex) => ({
    id: id,
    type: HEADING_WIDGET,
    widgetName: '',
    widgetIndex: widgetIndex,
    text: '',
    size: 1
})

let defaultState = []

const widgets = (widgets = defaultState, action) => {
    switch (action.type) {
        case MOVE_UP:
            return [
                ...widgets.slice(0, action.widgetIndex - 1),
                Object.assign({}, widgets[action.widgetIndex - 1], {
                    widgetIndex: widgets[action.widgetIndex - 1].widgetIndex + 1
                }),
                Object.assign({}, widgets[action.widgetIndex], {
                    widgetIndex: widgets[action.widgetIndex].widgetIndex - 1
                }),
                ...widgets.slice(action.widgetIndex + 1)
            ].sort((w1, w2) => (w1.widgetIndex - w2.widgetIndex))
        case MOVE_DOWN:
            return [
                ...widgets.slice(0, action.widgetIndex),
                Object.assign({}, widgets[action.widgetIndex], {
                    widgetIndex: widgets[action.widgetIndex].widgetIndex + 1
                }),
                Object.assign({}, widgets[action.widgetIndex + 1], {
                    widgetIndex: widgets[action.widgetIndex + 1].widgetIndex - 1
                }),
                ...widgets.slice(action.widgetIndex + 2)
            ].sort((w1, w2) => (w1.widgetIndex - w2.widgetIndex))
        case ADD_WIDGET:
            // ids generated by client end in 5 to differentiate from server generated ids
            let newId = Math.trunc(((new Date()).getTime() % 2147483647) / 10) * 10 + 5
            return [
                ...widgets,
                defaultWidget(newId, widgets.length)
            ]
        case DELETE_WIDGET:
            let deleteIndex = widgets.findIndex(w => {
                return w.id === action.widgetId;
            })
            widgets = widgets.map(w => {
                if (w.widgetIndex > deleteIndex) {
                    w.widgetIndex--;
                }
                return w
            })
            return widgets.filter(
                widget => widget.id !== action.widgetId
            )
        case UPDATE_WIDGET:
            return widgets.map(widget => {
                if (widget.id === action.widget.id) {
                    return action.widget
                } else {
                    return widget
                }
            })
        case SAVE_WIDGETS:
            let tmp = widgets.slice().sort((a, b) => (a.widgetName.localeCompare(b.widgetName)))
            for (var i = 0; i < tmp.length-1; i++) {
                if (tmp[i].widgetName === tmp[i+1].widgetName) {
                    alert('error: two widgets have the same name');
                    return action.widgets;
                }
            }
            alert('saved widgets to server');
            widgetService.saveWidgets(tId, action.widgets);
            return action.widgets;
        case LOAD_WIDGETS:
            return action.widgets.sort((w1, w2) => (w1.widgetIndex - w2.widgetIndex));
        default: return widgets;
    }
}

export default widgets;